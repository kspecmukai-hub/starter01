<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>starter01 | Camera Base</title>
  <style>
    :root { --ui-bg:#111; --ui-card:#1a1a1a; --ui-fg:#fff; --ui-accent:#4ade80; }
    *{ box-sizing:border-box }
    html,body{ height:100%; margin:0 }
    body{ background:#000; color:#eaeaea; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif }

    /* ステージ */
    #stage{ position:relative; width:100vw; height:100vh; overflow:hidden; background:#000 }
    #video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; background:#000 }
    .mirror{ transform:scaleX(-1) }

    /* 服PNG（肩追従＋フェードイン） */
    #garment{
      position:absolute; top:50%; left:50%;
      transform:translate(-50%,-50%); /* 左右の微調整は transform で、肩アンカーは top を補正 */
      max-width:none; pointer-events:none;
      opacity:0; transition:opacity .22s ease;
    }
    #garment.on{ opacity:1 }

    /* スタート画面 */
    #startScreen{ position:absolute; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.55) }
    #startCard{ background:#fff; color:#111; padding:20px 24px; border-radius:16px; width:min(92vw,520px); box-shadow:0 8px 32px rgba(0,0,0,.35) }
    #startCard h1{ margin:0 0 10px; font-size:20px }
    #startCard p{ margin:0 0 14px; line-height:1.6 }
    #startBtn{ width:100%; padding:12px 16px; border-radius:12px; border:0; font-size:16px; cursor:pointer; background:#111; color:#fff }

    /* 右下トグル & パネル */
    #toggle{ position:fixed; right:16px; bottom:16px; width:52px; height:52px; border-radius:999px; border:0; background:var(--ui-accent); color:#111; font-size:22px; box-shadow:0 8px 28px rgba(0,0,0,.35); cursor:pointer }
    #panel{ position:fixed; right:16px; bottom:86px; width:min(92vw,360px); background:var(--ui-card); color:var(--ui-fg); border:1px solid #2a2a2a; border-radius:16px; box-shadow:0 20px 40px rgba(0,0,0,.45); padding:12px; transform-origin:100% 100%; transform:scale(.9); opacity:0; pointer-events:none; transition:.18s ease }
    #panel.open{ transform:scale(1); opacity:1; pointer-events:auto }
    #panel h2{ margin:4px 6px 10px; font-size:14px; font-weight:600; opacity:.9 }
    .row{ display:flex; align-items:center; gap:8px; margin:8px 6px }
    .row label{ min-width:110px; font-size:14px; opacity:.9 }
    .hint{ margin:6px; font-size:12px; opacity:.7 }
    #badge{ font-size:12px; padding:2px 8px; border-radius:999px; background:#333; color:#fff }

    #log{ position:fixed; left:50%; bottom:16px; transform:translateX(-50%); background:#111; color:#fff; padding:6px 10px; border-radius:10px; font-size:12px; box-shadow:0 8px 28px rgba(0,0,0,.35); max-width:92vw; text-align:center; display:none }
  </style>
</head>
<body>
  <div id="stage" aria-label="camera stage">
    <video id="video" autoplay playsinline muted></video>
    <img id="garment" src="public/garments/trainer.png" alt="garment"/>
    <div id="startScreen"><div id="startCard">
      <h1>カメラの準備をします</h1>
      <p>「カメラを開始」を押すと、ブラウザからカメラ許可を聞かれます。インカメで開始し、ミラー表示（左右反転）になります。</p>
      <button id="startBtn">カメラを開始</button>
      <p class="hint">※ 後から右下の⚙で「アウトカメ／ミラーOFF」に切替できます。</p>
    </div></div>
  </div>

  <button id="toggle" title="設定">⚙</button>

  <div id="panel" role="dialog" aria-modal="false" aria-label="設定">
    <h2>設定</h2>
    <div class="row"><label for="modeBtn">カメラ</label><button id="modeBtn" type="button">イン（ミラーON）に起動中</button></div>
    <div class="row"><label for="mirrorChk">ミラー</label><input id="mirrorChk" type="checkbox" checked /></div>
    <div class="row"><label for="deviceSel">デバイス</label><select id="deviceSel"></select></div>

    <div class="row"><label for="showGarment">服表示</label><input id="showGarment" type="checkbox" /></div>

    <div class="row"><label for="autoFitChk">オート調整</label><input id="autoFitChk" type="checkbox" checked /></div>
    <div class="row"><label for="fitGain">フィット微調整</label><input id="fitGain" type="range" min="80" max="120" value="100" /> <span id="fitGainVal">100%</span></div>

    <div class="row"><label for="posX">横位置（微調整）</label><input id="posX" type="range" min="-40" max="40" value="0" /></div>
    <div class="row"><label for="posY">縦位置（微調整）</label><input id="posY" type="range" min="-40" max="40" value="0" /></div>
    <div class="row"><label for="scale">サイズ（手動）</label><input id="scale" type="range" min="50" max="150" value="100" /></div>

    <div class="row"><label>肩検出</label><span id="badge">初期化中…</span></div>
    <div class="row"><button id="stopBtn" type="button">停止</button><button id="restartBtn" type="button">再起動</button></div>
    <p class="hint">肩が映っている時だけ自動で表示（手動ONとのAND）。検出できない環境では手動表示を維持します。</p>
  </div>

  <div id="log" role="status"></div>

  <!-- ローカルESM（CDN不使用） -->
  <script type="module">
    import * as vision from './vendor/mediapipe/vision_bundle.mjs';
    const { FilesetResolver, PoseLandmarker } = vision;
    const WASM_BASE = './vendor/mediapipe/wasm';

   // --- 調整パラメータ ------------------------------------
const ALPHA_POS   = 0.16;   // 位置スムージング（大きいほど滑らか/遅い）
const ALPHA_SCALE = 0.12;   // スケールスムージング
const HOLD_MS     = 180;    // 一時未検出のホールド
const ANCHOR_Y_FRAC = 0.28; // 服画像内「肩ライン」の縦位置（0:上端, 1:下端）
const DROP_K      = 0.14;   // 肩幅pxに対する自動ドロップ割合（下げ率）←これが肝
// -------------------------------------------------------

    let stream=null, facing='user';
    let landmarker=null, landmarkerReady=false, shoulderOK=false, lastOKts=0;
    let lastVideoTime=-1;

    // 追従・スケール関連
    let smoothX=null, smoothY=null;
    let autoScaleRaw=1, autoScaleSm=1;   // スケールの平滑化
    let autoScale=1;
    let GARMENT_CHEST_PX=null;           // 服PNGの肩幅px（ヒント）
    let garmentNatW=0, garmentNatH=0;    // 服PNGの自然サイズ

    const els = {
      stage: document.getElementById('stage'),
      video: document.getElementById('video'),
      garment: document.getElementById('garment'),
      startScreen: document.getElementById('startScreen'),
      startBtn: document.getElementById('startBtn'),
      toggle: document.getElementById('toggle'),
      panel: document.getElementById('panel'),
      modeBtn: document.getElementById('modeBtn'),
      mirrorChk: document.getElementById('mirrorChk'),
      deviceSel: document.getElementById('deviceSel'),
      showGarment: document.getElementById('showGarment'),
      autoFitChk: document.getElementById('autoFitChk'),
      fitGain: document.getElementById('fitGain'),
      fitGainVal: document.getElementById('fitGainVal'),
      posX: document.getElementById('posX'),
      posY: document.getElementById('posY'),
      scale: document.getElementById('scale'),
      stopBtn: document.getElementById('stopBtn'),
      restartBtn: document.getElementById('restartBtn'),
      badge: document.getElementById('badge'),
      log: document.getElementById('log'),
    };

    const toast=(m,ms=2200)=>{ els.log.textContent=m; els.log.style.display='block';
      clearTimeout(els.log._t); els.log._t=setTimeout(()=>els.log.style.display='none',ms); };
    const stopStream=()=>{ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } };
    const vminPX=()=> Math.min(innerWidth, innerHeight)/100;
    const lerp=(a,b,t)=> a+(b-a)*t;
    const clamp=(v,lo,hi)=> Math.min(hi, Math.max(lo,v));

    function updateGarmentTransform(){
      const dx = +els.posX.value * vminPX();
      const dy = +els.posY.value * vminPX();
      const manual = +els.scale.value/100;
      const gain   = +els.fitGain.value/100;
      const mirror = els.mirrorChk.checked ? -1 : 1;

      autoScale = els.autoFitChk.checked ? autoScaleSm * gain : 1;
      const s = autoScale * manual;

      // transform は左右微調整・拡大縮小のみ（縦の肩アンカー補正は style.top 側で反映）
      els.garment.style.transform =
        `translate(-50%,-50%) scaleX(${mirror}) translate(${dx}px, ${dy}px) scale(${s})`;

      // 肩アンカー補正：画像中心ではなく肩ラインが肩中点に来るよう top をシフト
      if(garmentNatH){
        const anchorOffset = (0.5 - ANCHOR_Y_FRAC) * garmentNatH * s; // px
        if(typeof updateGarmentTransform._baseY === 'number'){
          els.garment.style.top = `${updateGarmentTransform._baseY + anchorOffset}px`;
        }
      }
    }

    function applyMirror(){ els.video.classList.toggle('mirror', els.mirrorChk.checked); updateGarmentTransform(); }
    function setModeLabel(){ const isUser=facing==='user';
      els.modeBtn.textContent=isUser?'イン（ミラーON）に起動中':'アウト（反転OFF）に起動中';
      els.mirrorChk.checked=isUser; applyMirror(); }
    function refreshGarmentDisplay(){
      const on = els.showGarment.checked && shoulderOK;
      els.garment.classList.toggle('on', on);
    }
    const setBadge=(ok,text,color)=>{ els.badge.textContent=text; els.badge.style.background=color; };

    async function startCamera({deviceId}={}){
      try{
        stopStream();
        const constraints = deviceId? {video:{deviceId:{exact:deviceId}},audio:false}
                                    : {video:{facingMode:facing},audio:false};
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        els.video.srcObject = stream;

        const devices=await navigator.mediaDevices.enumerateDevices();
        const cams=devices.filter(d=>d.kind==='videoinput'); const prev=els.deviceSel.value;
        els.deviceSel.innerHTML=''; cams.forEach(d=>{const o=document.createElement('option');
          o.value=d.deviceId; o.textContent=d.label||`カメラ ${els.deviceSel.length+1}`; els.deviceSel.appendChild(o);});
        if(deviceId && cams.some(c=>c.deviceId===deviceId)) els.deviceSel.value=deviceId;
        else if(cams.some(c=>c.deviceId===prev)) els.deviceSel.value=prev;

        smoothX = smoothY = null; // スムージング初期化
        toast('カメラを開始しました'); setModeLabel();
      }catch(e){ console.error(e); toast('カメラを開始できませんでした。別のブラウザ/端末も試してください。'); }
    }

    async function initPose(){
      try{
        setBadge(false,'初期化中…','#555');
        const fileset = await FilesetResolver.forVisionTasks(WASM_BASE);
        landmarker = await PoseLandmarker.createFromOptions(fileset, {
          baseOptions:{ modelAssetPath: `${WASM_BASE}/pose_landmarker_lite.task` },
          runningMode:'VIDEO', numPoses:1
        });
        landmarkerReady=true; setBadge(true,'検出準備OK','#2ea043'); toast('肩検出の準備ができました');
        requestAnimationFrame(tick);
      }catch(e){
        console.warn('Pose 初期化に失敗:', e);
        landmarkerReady=false; shoulderOK=false; setBadge(false,'未対応（手動表示）','#777');
      }
    }

    function tick(){
      if(!landmarkerReady || !els.video.srcObject){ requestAnimationFrame(tick); return; }
      const vtime=Math.round(els.video.currentTime*1000); if(vtime===lastVideoTime){ requestAnimationFrame(tick); return; }
      lastVideoTime=vtime;

      const res=landmarker.detectForVideo(els.video, performance.now());
      let ok=false, midXpx=innerWidth/2, midYpx=innerHeight/2, shoulderDistPX=null;

      if(res?.landmarks?.length){
        const lm=res.landmarks[0], L=lm[11], R=lm[12];
        if(L && R){
          const stageRect = els.stage.getBoundingClientRect();
          const videoRect = els.video.getBoundingClientRect();
          const baseX = videoRect.left - stageRect.left;
          const baseY = videoRect.top  - stageRect.top;

          // ミラー考慮でxを変換（px）
          const toPxX = xN => (els.mirrorChk.checked ? (1-xN) : xN) * videoRect.width + baseX;
          const toPxY = yN => yN * videoRect.height + baseY;

          // 肩中点（px）
          const cxN=(L.x+R.x)/2, cyN=(L.y+R.y)/2;
          midXpx = toPxX(cxN);
          midYpx = toPxY(cyN);

          // 肩幅px
          const lx=toPxX(L.x)-baseX, rx=toPxX(R.x)-baseX;
          const ly=L.y*videoRect.height, ry=R.y*videoRect.height;
          shoulderDistPX = Math.hypot(rx-lx, ry-ly);

          const vis=((L.visibility??1)>0.5)&&((R.visibility??1)>0.5);
          const inFrame= L.y>0 && L.y<1 && R.y>0 && R.y<1;
          ok = vis && inFrame;
        }
      }

      // 位置スムージング
      if(smoothX==null){ smoothX=midXpx; smoothY=midYpx; }
      else{
        smoothX = lerp(smoothX, midXpx, ALPHA_POS);
        smoothY = lerp(smoothY, midYpx, ALPHA_POS);
      }
      els.garment.style.left = `${smoothX}px`;
      // top は updateGarmentTransform 内で肩アンカー補正も含めて最終決定するため、
      // ここではベース値として保持
      updateGarmentTransform._baseY = smoothY;

      // 自動スケール（平滑化＋クランプ）
      if(shoulderDistPX && GARMENT_CHEST_PX){
        autoScaleRaw = clamp(shoulderDistPX / GARMENT_CHEST_PX, 0.4, 3.0);
        autoScaleSm  = lerp(autoScaleSm, autoScaleRaw, ALPHA_SCALE);
      }

      // 検出ホールド（点滅防止）
      if(ok) lastOKts = performance.now();
      const hold = (performance.now() - lastOKts) < HOLD_MS;
      shoulderOK = ok || hold;
      setBadge(shoulderOK, shoulderOK?'検出中':'未検出', shoulderOK?'#2ea043':'#555');

      updateGarmentTransform();  // スケール・左右/手動微調整・肩アンカー補正
      refreshGarmentDisplay();
      requestAnimationFrame(tick);
    }

    // UI
    els.startBtn.addEventListener('click', async ()=>{
      els.startBtn.disabled=true; await startCamera(); els.startScreen.style.display='none';
      if(!landmarkerReady) initPose();
    });
    els.toggle.addEventListener('click', ()=> els.panel.classList.toggle('open'));
    els.modeBtn.addEventListener('click', async ()=>{ facing=(facing==='user')?'environment':'user'; await startCamera(); });
    els.mirrorChk.addEventListener('change', applyMirror);
    els.deviceSel.addEventListener('change', async ()=>{ await startCamera({deviceId:els.deviceSel.value}); });
    els.stopBtn.addEventListener('click', ()=>{ stopStream(); toast('カメラを停止しました'); });
    els.restartBtn.addEventListener('click', async ()=>{ await startCamera(); });

    els.showGarment.addEventListener('change', refreshGarmentDisplay);
    [els.posX, els.posY, els.scale, els.fitGain].forEach(el=> el.addEventListener('input', ()=>{
      if(el===els.fitGain) els.fitGainVal.textContent = `${els.fitGain.value}%`;
      updateGarmentTransform();
    }));
    els.autoFitChk.addEventListener('change', updateGarmentTransform);

    // garments.json から肩幅pxヒント取得
    (async()=>{
      try{
        const r=await fetch('garments.json',{cache:'no-store'});
        const data=await r.json(); const key=Object.keys(data)[0]; const cfg=data[key]||{};
        if(typeof cfg.px_chest_hint==='number' && cfg.px_chest_hint>0){ GARMENT_CHEST_PX = cfg.px_chest_hint; }
      }catch(e){}
      // 画像の自然サイズ取得＋ヒントなければ推定
      els.garment.addEventListener('load', ()=>{
        garmentNatW = els.garment.naturalWidth;
        garmentNatH = els.garment.naturalHeight;
        if(!GARMENT_CHEST_PX){ GARMENT_CHEST_PX = garmentNatW * 0.70; }
        updateGarmentTransform();
      }, {once:true});
    })();

    addEventListener('resize', ()=> updateGarmentTransform());
  </script>
</body>
</html>


