<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>starter01 | Camera Base</title>
  <style>
    :root{
      --ui-bg:#111; --ui-card:#1a1a1a; --ui-fg:#fff; --ui-accent:#4ade80; --hint:#0ea5e9;
    }
    *{ box-sizing:border-box }
    html,body{ height:100%; margin:0 }
    body{ background:#000; color:#eaeaea; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif }

    /* ステージ（全画面カメラ） */
    #stage{ position:relative; width:100vw; height:100vh; overflow:hidden; background:#000 }
    #video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; background:#000; }
    .mirror{ transform: scaleX(-1); } /* 表示だけ左右反転 */

    /* 服PNG（追従対象） */
    #garment{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      max-width:90vmin; display:none; pointer-events:none;
      opacity:0; transition:opacity .18s ease;
    }

    /* スタート画面 */
    #startScreen{ position:absolute; inset:0; display:grid; place-items:center; background:rgba(0,0,0,.55); }
    #startCard{ background:#111; color:#eaeaea; padding:24px 28px; border-radius:16px; width:min(92vw,520px); box-shadow:0 8px 32px rgba(0,0,0,.35); }
    #startCard h1{ margin:0 0 10px; font-size:22px; }
    #startCard p{ margin:10px 0 14px; line-height:1.7; opacity:.9; }
    .btn{ appearance:none; border:0; border-radius:10px; padding:12px 16px; font-weight:700; cursor:pointer; }
    .btn.primary{ background:var(--ui-accent); color:#053; }
    .btn.ghost{ background:#222; color:#eaeaea; }

    /* 設定パネル */
    #panel{
      position:absolute; right:18px; bottom:86px; width:320px; max-width:92vw;
      background:#0f0f0f; color:#eaeaea; border-radius:16px; box-shadow:0 8px 32px rgba(0,0,0,.45);
      padding:14px 14px 12px; display:none;
    }
    #panel.open{ display:block; }
    #panel h2{ font-size:14px; margin:2px 0 10px; opacity:.85; }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:center; margin:8px 0; }
    .row > label{ font-size:12px; opacity:.9 }
    select, input[type="range"]{ width:100%; }
    input[type="checkbox"]{ transform:translateY(1px); }
    .hint{ font-size:11px; opacity:.8; line-height:1.5; }

    /* 浮遊ボタン */
    #toggle{
      position:absolute; right:20px; bottom:20px; width:48px; height:48px; border-radius:50%;
      display:grid; place-items:center; background:#10b981; color:#002; font-weight:800; cursor:pointer; box-shadow:0 6px 24px rgba(0,0,0,.35);
    }

    @media (max-width:420px){
      #panel{ right:12px; bottom:76px; }
      #startCard{ padding:20px; border-radius:12px; }
    }
  </style>
</head>
<body>
  <div id="stage" aria-label="camera stage">
    <video id="video" autoplay playsinline muted></video>
    <img id="garment" alt="garment" src="public/garments/trainer.png" />

    <div id="startScreen">
      <div id="startCard">
        <h1>カメラの準備をします</h1>
        <p>「カメラを開始」を押すと、ブラウザからカメラ許可を聞かれます。<br>インカメで開始し、ミラー表示（左右反転）になります。</p>
        <button id="startBtn" class="btn primary">カメラを開始</button>
        <p class="hint">※ 右下の⚙で「アウト／ミラーOFF」へ切替できます。</p>
      </div>
    </div>

    <div id="panel" role="dialog" aria-modal="false" aria-label="設定">
      <h2>設定</h2>

      <div class="row">
        <label>カメラ</label>
        <button id="modeBtn" type="button" class="btn ghost" style="padding:8px 10px">イン（ミラーON）に起動中</button>
      </div>

      <div class="row">
        <label for="mirrorChk">ミラー</label>
        <input id="mirrorChk" type="checkbox" checked />
      </div>

      <div class="row">
        <label for="devicesSel">デバイス</label>
        <select id="devicesSel"></select>
      </div>

      <div class="row">
        <label for="autoFitChk">オート調整</label>
        <input id="autoFitChk" type="checkbox" checked />
      </div>

      <div class="row">
        <label for="fitGain">フィット保護調整</label>
        <input id="fitGain" type="range" min="0" max="100" value="85" />
      </div>

      <div class="row">
        <label for="offX">横位置（微調整）</label>
        <input id="offX" type="range" min="-80" max="80" value="0" />
      </div>
      <div class="row">
        <label for="offY">縦位置（微調整）</label>
        <input id="offY" type="range" min="-120" max="120" value="0" />
      </div>

      <div class="row">
        <label for="scale">サイズ（手動）</label>
        <input id="scale" type="range" min="30" max="150" value="100" />
      </div>

      <div class="row">
        <label>肩検出</label>
        <span id="poseState" style="font-size:12px;background:#0a0; color:#021; border-radius:10px; padding:4px 6px; text-align:center">未検出</span>
      </div>

      <div class="row">
        <button id="stopBtn" class="btn ghost">停止</button>
        <button id="restartBtn" class="btn ghost">再起動</button>
      </div>

      <p class="hint">肩/腕が入る状態だと自動で表示。検出できない環境では非表示になります。</p>
    </div>

    <button id="toggle" title="設定">⚙</button>
  </div>

  <script type="module">
    /**** MediaPipe (ローカルESM) ****/
    import * as vision from './vendor/mediapipe/vision_bundle.mjs';
    const WASM_BASE = './vendor/mediapipe/wasm/';

    /**** 要素 ****/
    const els = {
      stage: stage, video: video, garment: garment,
      startScreen: startScreen, startBtn: startBtn,
      toggle: toggle, panel: panel, modeBtn: modeBtn, mirrorChk: mirrorChk, devicesSel: devicesSel,
      autoFitChk: autoFitChk, fitGain: fitGain, offX: offX, offY: offY, scale: scale,
      poseState: poseState, stopBtn: stopBtn, restartBtn: restartBtn,
    };

    /**** 調整パラメータ（応答性UP版） ****/
    const ALPHA_POS      = 0.20;  // 位置のスムージング
    const ALPHA_SCALE    = 0.28;  // スケールのスムージング（距離変化の反映を速く）
    const ALPHA_SHOULDER = 0.35;  // 肩幅pxのスムージング
    const HOLD_MS        = 80;    // 未検出保持（短め＝すぐ消える）
    const ANCHOR_Y_FRAC  = 0.28;  // 服画像内の肩ライン（0=上端〜1=下端）
    const DROP_K         = 0.14;  // 肩幅に対する自然な下げ量（ドロップ）

    /**** 状態 ****/
    let stream=null, currentDeviceId=null, facing='user', mirror=true;
    let landmarker=null, fileset=null;
    let lastDetMS=0, smX=null, smY=null, smS=1, smShoulder=null;
    let manualScale=1;
    let garmentNatW=0, garmentNatH=0, garmentConf=null;
    let autoDropPx=0;

    els.garment.addEventListener('load', ()=>{
      garmentNatW = els.garment.naturalWidth  || els.garment.width  || 1000;
      garmentNatH = els.garment.naturalHeight || els.garment.height || 1000;
    });

    /**** ユーティリティ ****/
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
    const lerp  = (a,b,t)=>a+(b-a)*t;

    async function listVideoDevices(){
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d=>d.kind==='videoinput');
      els.devicesSel.innerHTML = cams.map(d=>`<option value="${d.deviceId}" ${d.deviceId===currentDeviceId?'selected':''}>${d.label||'Camera'}</option>`).join('');
    }

    function applyMirror(){
      els.video.classList.toggle('mirror', mirror);
      els.garment.classList.toggle('mirror', mirror);
    }

    async function startCamera(){
      try{
        if(stream){ stream.getTracks().forEach(t=>t.stop()); }

        const constraints = { audio:false, video:{ facingMode:facing, width:{ideal:1280}, height:{ideal:720} } };
        if(currentDeviceId) constraints.video.deviceId = { exact: currentDeviceId };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        els.video.srcObject = stream; await els.video.play().catch(()=>{});
        els.startScreen.style.display = 'none';
        await listVideoDevices(); applyMirror();

        if(!landmarker){ await initPose(); }
        requestAnimationFrame(tick);
      }catch(err){
        console.error('startCamera error:', err);
        alert('カメラの開始に失敗しました。ブラウザの許可設定をご確認ください。');
      }
    }
    async function stopCamera(){ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } }
    async function restartCamera(){ await stopCamera(); await sleep(50); await startCamera(); }

    /**** Pose 初期化 ****/
    async function initPose(){
      try{
        fileset = await vision.FilesetResolver.forVisionTasks(WASM_BASE);
        landmarker = await vision.PoseLandmarker.createFromOptions(fileset, {
          baseOptions:{ modelAssetPath:`${WASM_BASE}pose_landmarker_lite.task` },
          runningMode:'VIDEO', numPoses:1,
          minPoseDetectionConfidence:.5, minPosePresenceConfidence:.5, minTrackingConfidence:.5,
        });
        console.info('Pose 初期化 OK');
      }catch(e){
        console.error('Pose 初期化エラー:', e);
        alert('姿勢検出の初期化に失敗しました（ファイル配置やパスを確認してください）');
      }
    }

    /**** garments.json 読込 ****/
    async function loadGarmentConfig(){
      try{
        const r = await fetch('garments.json',{cache:'no-store'});
        const data = await r.json();
        const firstKey = Object.keys(data)[0];
        garmentConf = data[firstKey] || null;
      }catch(e){ console.warn('garments.json 読込失敗:', e); }
    }

    /**** 服の変換を適用 ****/
    function updateGarmentTransform(){
      if(!garmentConf || garmentNatW===0) return;

      const baseScale = manualScale;
      let s = baseScale;

      // 自動フィット（肩幅→胸幅推定→px_chest_hint に合わせる）
      if(els.autoFitChk.checked && updateGarmentTransform._shoulderPX){
        const pxChestHint = garmentConf.px_chest_hint || 980;
        let targetChestPx = updateGarmentTransform._shoulderPX;
        if(garmentConf.chest_cm && garmentConf.shoulder_cm){
          targetChestPx = targetChestPx * (garmentConf.chest_cm/garmentConf.shoulder_cm);
        }
        const fitS = (pxChestHint>0) ? (targetChestPx/pxChestHint) : baseScale;
        const g = (parseInt(els.fitGain.value,10) || 85)/100; // 0〜1
        s = lerp(baseScale, fitS, g);
      }

      // スムージング
      smS = (smS==null) ? s : lerp(smS, s, ALPHA_SCALE);

      // 位置（肩の中心）
      const cx = updateGarmentTransform._cx ?? (els.stage.clientWidth/2);
      const cy = updateGarmentTransform._cy ?? (els.stage.clientHeight/2);
      smX = (smX==null) ? cx : lerp(smX, cx, ALPHA_POS);
      smY = (smY==null) ? cy : lerp(smY, cy, ALPHA_POS);

      // 実サイズ
      const w = garmentNatW * smS;
      const h = garmentNatH * smS;

      // 服画像の肩ライン（上=0 下=1）→ 肩を基準に配置
      const anchorOffset = (0.5 - ANCHOR_Y_FRAC) * h;

      // 手動オフセット
      const offX = parseInt(els.offX.value,10) || 0;
      const offY = parseInt(els.offY.value,10) || 0;

      els.garment.style.width = `${w}px`;
      els.garment.style.left  = `${smX + offX}px`;
      els.garment.style.top   = `${smY + anchorOffset + autoDropPx + offY}px`;
    }

    /**** メインループ ****/
    async function tick(){
      if(!landmarker || !els.video || !els.video.videoWidth){ requestAnimationFrame(tick); return; }

      const W = els.stage.clientWidth, H = els.stage.clientHeight;
      const now = performance.now();
      let ok=false;

      try{
        const result = landmarker.detectForVideo(els.video, now);
        const lm = (result.landmarks && result.landmarks[0]) ? result.landmarks[0] : null;
        if(lm){
          const L = lm[11], R = lm[12]; // 左右肩
          if(L && R){
            let cx = (L.x + R.x)/2 * W;
            let cy = (L.y + R.y)/2 * H;
            if(mirror){ cx = W - cx; }

            // 肩幅(px)をスムージング
            const shoulderPX_raw = Math.abs(R.x - L.x) * W;
            smShoulder = (smShoulder==null) ? shoulderPX_raw : lerp(smShoulder, shoulderPX_raw, ALPHA_SHOULDER);
            updateGarmentTransform._shoulderPX = smShoulder;

            // ドロップ量（肩幅に比例）
            autoDropPx = smShoulder * DROP_K;

            updateGarmentTransform._cx = cx;
            updateGarmentTransform._cy = cy;

            lastDetMS = now; ok = true;
          }
        }
      }catch(e){ console.warn('pose detect error:', e); }

      // 服の表示制御（自動のみ）
      const hold = (now - lastDetMS) < HOLD_MS;
      const wantShow = (ok || hold);
      els.garment.style.display = wantShow ? 'block' : 'none';
      els.garment.style.opacity = wantShow ? '1' : '0';

      els.poseState.textContent = ok ? '検出中' : (hold ? '保持中' : '未検出');
      els.poseState.style.background = ok ? '#0a0' : (hold ? '#996600' : '#555');

      updateGarmentTransform();
      requestAnimationFrame(tick);
    }

    /**** イベント ****/
    els.toggle.addEventListener('click', ()=> els.panel.classList.toggle('open'));

    els.modeBtn.addEventListener('click', async ()=>{
      facing = (facing==='user') ? 'environment' : 'user';
      mirror = (facing==='user'); applyMirror();
      els.mirrorChk.checked = mirror;
      els.modeBtn.textContent = (facing==='user') ? 'イン（ミラーON）に起動中' : 'アウト（ミラーOFF）に起動中';
      await restartCamera();
    });

    els.mirrorChk.addEventListener('change', ()=>{ mirror = !!els.mirrorChk.checked; applyMirror(); });
    els.devicesSel.addEventListener('change', async ()=>{ currentDeviceId = els.devicesSel.value || null; await restartCamera(); });

    ['offX','offY','scale','fitGain'].forEach(id=>{
      els[id].addEventListener('input', ()=>{
        if(id==='scale'){ manualScale = (+els.scale.value)/100; }
        updateGarmentTransform();
      });
    });
    els.autoFitChk.addEventListener('change', updateGarmentTransform);

    els.startBtn.addEventListener('click', startCamera);
    els.stopBtn.addEventListener('click', stopCamera);
    els.restartBtn.addEventListener('click', restartCamera);

    window.addEventListener('resize', ()=>{ smX=null; smY=null; updateGarmentTransform(); });

    // 初期ロード
    (async ()=>{
      els.mirrorChk.checked = mirror;
      els.modeBtn.textContent = 'イン（ミラーON）に起動中';
      manualScale = (+els.scale.value)/100;
      await loadGarmentConfig();
    })();
  </script>
</body>
</html>
