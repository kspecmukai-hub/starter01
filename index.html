<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <title>starter01 | Camera Base</title>
  <style>
    :root{
      --ui-fg:#fff; --ui-bg:#000;
      --ui-accent:#22c55e; --ui-accent-2:#10b981;
      --ui-muted:rgba(255,255,255,.65);
      --ui-card:#111; --ui-shadow:0 10px 30px rgba(0,0,0,.25);
    }
    *{ box-sizing:border-box }
    html,body{ height:100%; margin:0 }
    body{
      background:var(--ui-bg); color:var(--ui-fg);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP",sans-serif;
      -webkit-tap-highlight-color: transparent; touch-action: manipulation;
    }
    /* ===== Stage ===== */
    #stage{ position:relative; width:100vw; height:100vh; overflow:hidden; background:#000; user-select:none; }
    #video{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; background:#000; transform-origin:center center; will-change:transform; }
    #garment{ position:absolute; left:0; top:0; will-change:transform,left,top,width,opacity; pointer-events:none; image-rendering:auto; filter:none; transform-origin: 0 0; }
    .mirror{ transform: scaleX(-1); }

    /* ===== Floating Settings Button ===== */
    #fab{ position:absolute; right:16px; bottom:24px; width:56px; height:56px; border-radius:50%; background:var(--ui-accent);
      color:#002b10; display:grid; place-items:center; box-shadow:var(--ui-shadow); cursor:pointer; z-index:50; transition:transform .1s ease; }
    #fab:active{ transform: scale(.98) } #fab svg{ width:26px; height:26px }

    /* ===== Settings Card ===== */
    #panel{ position:absolute; right:12px; bottom:92px; width:min(92vw,360px); padding:14px 14px 12px; border-radius:16px;
      background:rgba(20,20,20,.94); box-shadow:var(--ui-shadow); backdrop-filter: blur(8px); z-index:60; display:none; }
    #panel.show{ display:block }
    .row{ display:flex; align-items:center; gap:10px; margin:10px 0 }
    .row label{ font-size:14px; color:var(--ui-muted); min-width:6em }
    .row input[type="range"]{ flex:1 }
    .row .val{ width:64px; text-align:right; color:#bfead2; font-variant-numeric: tabular-nums }
    .row .switch{ display:flex; align-items:center; gap:10px }
    .btn{ appearance:none; border:0; border-radius:10px; background:#222; color:#fff; padding:10px 12px; cursor:pointer; }
    .btn.primary{ background:var(--ui-accent-2); color:#06251a }
    .small{ font-size:12px; color:var(--ui-muted) }
    .caption{ font-size:12px; color:#a7f3d0; line-height:1.4; margin-top:8px }

    /* ===== PC Overlay ===== */
    #pcOverlay{ position:absolute; inset:0; background: rgba(0,0,0,.85); color:#fff; display:none; z-index:100; align-items:center; justify-content:center; text-align:center; padding:24px; }
    #pcOverlay.show{ display:flex }
    #pcOverlay .card{ background:#111; border:1px solid #333; padding:18px 16px; border-radius:16px; max-width:520px; box-shadow:var(--ui-shadow); }
    #pcOverlay h2{ margin:0 0 8px; font-weight:700 } #pcOverlay p{ margin:6px 0; color:#e5e7eb }
    #pcOverlay code{ background:#0b0b0b; border:1px solid #222; padding:4px 6px; border-radius:6px;
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; color:#93c5fd; }

    #status{ position:absolute; left:10px; top:8px; font-size:12px; color:#bfead2; background:rgba(0,0,0,.4);
      padding:6px 8px; border-radius:8px; z-index:40; pointer-events:none; }
    a,button,input,select{ font:inherit }
  </style>
</head>
<body>
  <div id="stage">
    <video id="video" playsinline muted></video>
    <img id="garment" alt="garment" aria-hidden="true"/>

    <div id="status" class="small">loading…</div>

    <div id="pcOverlay">
      <div class="card">
        <h2>スマホ専用です 📱</h2>
        <p>この体験はスマートフォンのカメラ前提で最適化されています。</p>
        <p class="small">UA: <code id="uaTxt"></code></p>
        <p class="small">スマホで本ページを開いてください。</p>
      </div>
    </div>

    <div id="fab" title="設定">
      <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7zM19.43 12.98a7.996 7.996 0 0 0 .06-1l1.74-1.35a.5.5 0 0 0 .12-.64l-1.65-2.86a.5.5 0 0 0-.6-.22l-2.05.83a7.9 7.9 0 0 0-.86-.5l-.31-2.2a.5.5 0 0 0-.49-.43h-3.3a.5.5 0 0 0-.49.43l-.31 2.2c-.29.14-.58.31-.86.5l-2.05-.83a.5.5 0 0 0-.6.22L3.65 9a.5.5 0 0 0 .12.64L5.5 11a8.3 8.3 0 0 0 0 2L3.77 14.35a.5.5 0 0 0-.12.64l1.65 2.86a.5.5 0 0 0 .6.22l2.05-.83c.28.19.57.36.86.5l.31 2.2a.5.5 0 0 0 .49.43h3.3a.5.5 0 0 0 .49-.43l.31-2.2c.29-.14.58-.31.86-.5l2.05.83a.5.5 0 0 0 .6-.22l1.65-2.86a.5.5 0 0 0-.12-.64L19.43 13z"/></svg>
    </div>

    <div id="panel" role="dialog" aria-label="設定">
      <div class="row">
        <label>ミラー</label>
        <div class="switch">
          <input id="chkMirror" type="checkbox" />
          <span class="small">ONにすると鏡のように見えます</span>
        </div>
      </div>
      <div class="row">
        <label>横 微調整</label>
        <input id="rngX" type="range" min="-60" max="60" step="1" value="0" />
        <div class="val"><span id="valX">0</span>px</div>
      </div>
      <div class="row">
        <label>縦 微調整</label>
        <input id="rngY" type="range" min="-60" max="60" step="1" value="0" />
        <div class="val"><span id="valY">0</span>px</div>
      </div>
      <div class="row" style="justify-content:flex-end; gap:8px">
        <button id="btnReset" class="btn">微調整リセット</button>
        <button id="btnRestart" class="btn primary">停止/再開</button>
      </div>
      <div class="caption" id="presetInfo">preset: …</div>
    </div>
  </div>

  <script type="module">
    import { FilesetResolver, PoseLandmarker } from "./vendor/mediapipe/vision_bundle.mjs";

    // ===== Tunables =====
    const ALPHA_POS   = 0.16;
    const ALPHA_SCALE = 0.12;
    const HOLD_MS     = 600;
    const FIT_GAIN    = 1.0;

    // Defaults (presets.json で上書き)
    const DEFAULTS = {
      anchorY: 0.33,
      dropK: 0.14,
      xBiasFrac: 0,
      yBiasFrac: 0,
      yCompFrac: 0, // ← 距離補正（スケール差→縦補正）係数
      scaleRef: 1   // ← 補正の基準スケール
    };

    // ===== Elements =====
    const stage   = document.getElementById('stage');
    const videoEl = document.getElementById('video');
    const garment = document.getElementById('garment');
    const fab     = document.getElementById('fab');
    const panel   = document.getElementById('panel');
    const chkMirror = document.getElementById('chkMirror');
    const rngX = document.getElementById('rngX'); const rngY = document.getElementById('rngY');
    const valX = document.getElementById('valX'); const valY = document.getElementById('valY');
    const btnReset = document.getElementById('btnReset'); const btnRestart = document.getElementById('btnRestart');
    const presetInfo = document.getElementById('presetInfo');
    const statusEl = document.getElementById('status');
    const pcOverlay = document.getElementById('pcOverlay'); const uaTxt = document.getElementById('uaTxt');

    // ===== State =====
    let PRESET = { ...DEFAULTS };
    let garmentMeta = null; // { image, px_chest_hint, chest_cm, shoulder_cm, anchorY, _w, _h }
    let fileset, landmarker;
    let running = true;
    let lastHasPoseTs = 0;
    let prevTx = NaN, prevTy = NaN, prevScale = NaN;

    // user micro offsets (px)
    window.userOffsetX_px = 0;
    window.userOffsetY_px = 0;

    let mirrored = false;

    // ===== Utilities =====
    const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
    const stripBOM = (t)=> t.replace(/^\uFEFF/,'');

    async function strictFetchJSON(url){
      const res = await fetch(url, { cache:"no-store" });
      const txt = stripBOM(await res.text());
      try{ return JSON.parse(txt); }
      catch(err){ console.error("JSON parse error:", url, err); throw new Error(`JSON parse error @ ${url}`); }
    }

    function pickPresetFromUA(presets, ua) {
      const models = presets.models || [];
      for (const m of models) {
        if (!m.match) continue;
        const re = new RegExp(m.match, 'i');
        if (re.test(ua)) return { ...presets.defaults, ...m };
      }
      return { ...(presets.defaults || {}) };
    }

    function lerp(a,b,alpha){ if (Number.isNaN(a)) return b; return a + (b - a) * alpha; }
    function isMobileUA(){ return /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); }

    // ===== Load garments.json (first key only) =====
    async function loadGarmentMeta(){
      const all = await strictFetchJSON("./garments.json");
      const firstKey = Object.keys(all)[0];
      const g = all[firstKey] || {};
      return {
        name: g.name ?? "garment",
        image: g.image ?? "public/garments/trainer.png",
        px_chest_hint: g.px_chest_hint ?? 980,
        chest_cm: g.chest_cm ?? null,
        shoulder_cm: g.shoulder_cm ?? null,
        anchorY: (typeof g.anchorY === 'number') ? g.anchorY : DEFAULTS.anchorY,
        anchorX: (typeof g.anchorX === 'number') ? g.anchorX : 0.5
      };
    }

    // ===== Camera =====
    async function startCamera(){
      const constraints = { video: { facingMode:"user", width:{ ideal:1280 }, height:{ ideal:720 }}, audio:false };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      videoEl.srcObject = stream; await videoEl.play();
    }

    // ===== Pose Landmarker =====
    async function initLandmarker(){
      fileset = await FilesetResolver.forVisionTasks("./vendor/mediapipe/wasm");
      landmarker = await PoseLandmarker.createFromOptions(fileset, {
        baseOptions: { modelAssetPath: "./vendor/mediapipe/wasm/pose_landmarker_lite.task" },
        runningMode: "VIDEO",
        numPoses: 1
      });
    }

    // ===== Main Loop =====
    async function runLoop(){
      const process = async () => {
        if (!running || videoEl.readyState < 2) { requestAnimationFrame(process); return; }

        const ts = performance.now();
        const res = await landmarker.detectForVideo(videoEl, ts);

        const stageW = stage.clientWidth;
        const stageH = stage.clientHeight;

        let hasPose = false;

        if (res && res.landmarks && res.landmarks[0]) {
          const lm = res.landmarks[0];
          const L = lm[11]; // left shoulder
          const R = lm[12]; // right shoulder
          if (L && R) {
            hasPose = true;
            lastHasPoseTs = ts;

            // 1) shoulder center (normalized → px)
            const cx = ((L.x + R.x) * 0.5) * stageW;
            const cy = ((L.y + R.y) * 0.5) * stageH;

            // 2) shoulder width (px)
            const shoulderPX = Math.abs(R.x - L.x) * stageW;

            // 3) chest width px estimate
            let chestPX = shoulderPX;
            if (garmentMeta.chest_cm && garmentMeta.shoulder_cm) {
              chestPX = shoulderPX * (garmentMeta.chest_cm / garmentMeta.shoulder_cm);
            }

            // 4) auto drop
            const dropK = (typeof PRESET.dropK === 'number') ? PRESET.dropK : DEFAULTS.dropK;
            const autoDropPx = shoulderPX * dropK;

            // 5) scale vs px_chest_hint
            const pxHint = garmentMeta.px_chest_hint || 980;
            const rawScale = (chestPX / pxHint) * FIT_GAIN;

            // 6) target position base
            let tx = cx;
            let ty = cy + autoDropPx;

            // 7) preset biases (frac → px)
            tx += (PRESET.xBiasFrac || 0) * stageW;
            ty += (PRESET.yBiasFrac || 0) * stageH;

            // 8) user UI offsets (px)
            tx += (window.userOffsetX_px || 0);
            ty += (window.userOffsetY_px || 0);

            // 9) smoothing
            const s  = prevScale = lerp(prevScale, rawScale, ALPHA_SCALE);
            const sx = prevTx    = lerp(prevTx,    tx,       ALPHA_POS);
            const sy = prevTy    = lerp(prevTy,    ty,       ALPHA_POS);

            // 10) distance-aware vertical compensation (scale drift fix)
            const ref  = (PRESET.scaleRef ?? DEFAULTS.scaleRef) || 1;
            const comp = (PRESET.yCompFrac ?? DEFAULTS.yCompFrac) || 0;
            // s < ref（遠い）→ (ref - s) > 0 → 上方向へ持ち上げ
            const yLiftPx = comp * (ref - s) * stageH;
            const syComp  = sy - yLiftPx;

            // 11) place garment
            if (garmentMeta._w && garmentMeta._h) {
              const gw = garmentMeta._w * s;
              const gh = garmentMeta._h * s;

              const left = sx - gw * (garmentMeta.anchorX ?? 0.5);
              const top  = syComp - gh * (garmentMeta.anchorY ?? PRESET.anchorY ?? DEFAULTS.anchorY);

              garment.style.width = `${gw}px`;
              garment.style.left  = `${left}px`;
              garment.style.top   = `${top}px`;
              garment.style.opacity = '1';
            }
          }
        }

        // HOLD
        if (!hasPose) {
          const dt = performance.now() - lastHasPoseTs;
          if (dt > HOLD_MS) garment.style.opacity = '0';
        }
        requestAnimationFrame(process);
      };
      requestAnimationFrame(process);
    }

    // ===== UI =====
    const togglePanel = ()=> panel.classList.toggle('show');
    fab.addEventListener('click', togglePanel);

    chkMirror.addEventListener('change', (e)=>{
      const on = !!e.target.checked; mirrored = on;
      [videoEl, garment].forEach(el=> el.classList.toggle('mirror', on));
    });

    function updateRangeLabels(){
      valX.textContent = String(window.userOffsetX_px|0);
      valY.textContent = String(window.userOffsetY_px|0);
    }
    rngX.addEventListener('input', (e)=>{ window.userOffsetX_px = parseInt(e.target.value,10) || 0; updateRangeLabels(); });
    rngY.addEventListener('input', (e)=>{ window.userOffsetY_px = parseInt(e.target.value,10) || 0; updateRangeLabels(); });
    btnReset.addEventListener('click', ()=>{
      window.userOffsetX_px = 0; window.userOffsetY_px = 0;
      rngX.value = "0"; rngY.value = "0"; updateRangeLabels();
    });
    btnRestart.addEventListener('click', ()=>{
      running = !running;
      btnRestart.textContent = running ? "停止" : "再開";
      if (running) lastHasPoseTs = performance.now();
    });

    function updatePresetInfo(){
      const p = PRESET;
      const gy = (typeof garmentMeta?.anchorY === 'number') ? garmentMeta.anchorY : (p.anchorY ?? DEFAULTS.anchorY);
      presetInfo.textContent =
        `preset: anchorY=${gy.toFixed(3)}, dropK=${(p.dropK??DEFAULTS.dropK).toFixed(3)}, `
        + `xBias=${((p.xBiasFrac||0)*100).toFixed(1)}%, yBias=${((p.yBiasFrac||0)*100).toFixed(1)}%, `
        + `yComp=${((p.yCompFrac||0)*100).toFixed(1)}%/scale, ref=${(p.scaleRef??DEFAULTS.scaleRef).toFixed(2)}`;
    }

    // ===== Boot =====
    (async function main(){
      try{
        // PC overlay
        const ua = navigator.userAgent || '';
        uaTxt.textContent = ua;
        if (!isMobileUA()) pcOverlay.classList.add('show');

        statusEl.textContent = 'loading presets…';
        const presets = await strictFetchJSON("./presets.json");
        const picked = pickPresetFromUA(presets, ua);
        PRESET = { ...DEFAULTS, ...picked };

        statusEl.textContent = 'loading garment…';
        garmentMeta = await loadGarmentMeta();

        await new Promise((resolve, reject)=>{
          garment.onload = ()=>{ garmentMeta._w = garment.naturalWidth; garmentMeta._h = garment.naturalHeight; resolve(); };
          garment.onerror = reject;
          garment.src = garmentMeta.image;
        });

        updatePresetInfo(); updateRangeLabels();

        statusEl.textContent = 'starting camera…';
        await startCamera();

        statusEl.textContent = 'loading pose model…';
        await initLandmarker();

        statusEl.textContent = 'running';
        await sleep(50); statusEl.style.display = 'none';

        [videoEl, garment].forEach(el=>el.classList.toggle('mirror', mirrored));
        runLoop();

        window.addEventListener('resize', ()=>{ prevTx = prevTy = prevScale = NaN; });
      }catch(err){
        console.error(err);
        statusEl.textContent = 'error: ' + err.message;
      }
    })();
  </script>
</body>
</html>
